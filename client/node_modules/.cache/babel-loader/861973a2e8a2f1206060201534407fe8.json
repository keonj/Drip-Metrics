{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isSharded = exports.applyCommonQueryOptions = exports.getReadPreference = void 0;\n\nconst error_1 = require(\"../../error\");\n\nconst read_preference_1 = require(\"../../read_preference\");\n\nconst common_1 = require(\"../../sdam/common\");\n\nconst topology_description_1 = require(\"../../sdam/topology_description\");\n\nfunction getReadPreference(cmd, options) {\n  // Default to command version of the readPreference\n  let readPreference = cmd.readPreference || read_preference_1.ReadPreference.primary; // If we have an option readPreference override the command one\n\n  if (options === null || options === void 0 ? void 0 : options.readPreference) {\n    readPreference = options.readPreference;\n  }\n\n  if (typeof readPreference === 'string') {\n    readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n  }\n\n  if (!(readPreference instanceof read_preference_1.ReadPreference)) {\n    throw new error_1.MongoInvalidArgumentError('Option \"readPreference\" must be a ReadPreference instance');\n  }\n\n  return readPreference;\n}\n\nexports.getReadPreference = getReadPreference;\n\nfunction applyCommonQueryOptions(queryOptions, options) {\n  Object.assign(queryOptions, {\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true\n  });\n\n  if (options.session) {\n    queryOptions.session = options.session;\n  }\n\n  return queryOptions;\n}\n\nexports.applyCommonQueryOptions = applyCommonQueryOptions;\n\nfunction isSharded(topologyOrServer) {\n  if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {\n    return true;\n  } // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n\n\n  if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {\n    const servers = Array.from(topologyOrServer.description.servers.values());\n    return servers.some(server => server.type === common_1.ServerType.Mongos);\n  }\n\n  return false;\n}\n\nexports.isSharded = isSharded;","map":{"version":3,"sources":["C:\\Western\\Ivey\\WEC\\Drip-Metrics\\Drip-Metrics\\node_modules\\mongodb\\src\\cmap\\wire_protocol\\shared.ts"],"names":[],"mappings":";;;;;;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAEA,MAAA,iBAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAIA,MAAA,sBAAA,GAAA,OAAA,CAAA,iCAAA,CAAA;;AAQA,SAAgB,iBAAhB,CAAkC,GAAlC,EAAiD,OAAjD,EAA+E;AAC7E;AACA,MAAI,cAAc,GAAG,GAAG,CAAC,cAAJ,IAAsB,iBAAA,CAAA,cAAA,CAAe,OAA1D,CAF6E,CAG7E;;AACA,MAAI,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,cAAb,EAA6B;AAC3B,IAAA,cAAc,GAAG,OAAO,CAAC,cAAzB;AACD;;AAED,MAAI,OAAO,cAAP,KAA0B,QAA9B,EAAwC;AACtC,IAAA,cAAc,GAAG,iBAAA,CAAA,cAAA,CAAe,UAAf,CAA0B,cAA1B,CAAjB;AACD;;AAED,MAAI,EAAE,cAAc,YAAY,iBAAA,CAAA,cAA5B,CAAJ,EAAiD;AAC/C,UAAM,IAAI,OAAA,CAAA,yBAAJ,CACJ,2DADI,CAAN;AAGD;;AAED,SAAO,cAAP;AACD;;AAnBD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAqBA,SAAgB,uBAAhB,CACE,YADF,EAEE,OAFF,EAEyB;AAEvB,EAAA,MAAM,CAAC,MAAP,CAAc,YAAd,EAA4B;AAC1B,IAAA,GAAG,EAAE,OAAO,OAAO,CAAC,GAAf,KAAuB,SAAvB,GAAmC,OAAO,CAAC,GAA3C,GAAiD,KAD5B;AAE1B,IAAA,YAAY,EAAE,OAAO,OAAO,CAAC,YAAf,KAAgC,SAAhC,GAA4C,OAAO,CAAC,YAApD,GAAmE,IAFvD;AAG1B,IAAA,aAAa,EAAE,OAAO,OAAO,CAAC,aAAf,KAAiC,SAAjC,GAA6C,OAAO,CAAC,aAArD,GAAqE,IAH1D;AAI1B,IAAA,cAAc,EAAE,OAAO,OAAO,CAAC,cAAf,KAAkC,SAAlC,GAA8C,OAAO,CAAC,cAAtD,GAAuE,KAJ7D;AAK1B,IAAA,UAAU,EAAE,OAAO,OAAO,CAAC,UAAf,KAA8B,SAA9B,GAA0C,OAAO,CAAC,UAAlD,GAA+D,KALjD;AAM1B,IAAA,oBAAoB,EAClB,OAAO,OAAO,CAAC,oBAAf,KAAwC,SAAxC,GAAoD,OAAO,CAAC,oBAA5D,GAAmF;AAP3D,GAA5B;;AAUA,MAAI,OAAO,CAAC,OAAZ,EAAqB;AACnB,IAAA,YAAY,CAAC,OAAb,GAAuB,OAAO,CAAC,OAA/B;AACD;;AAED,SAAO,YAAP;AACD;;AAnBD,OAAA,CAAA,uBAAA,GAAA,uBAAA;;AAqBA,SAAgB,SAAhB,CAA0B,gBAA1B,EAA0E;AACxE,MAAI,gBAAgB,CAAC,WAAjB,IAAgC,gBAAgB,CAAC,WAAjB,CAA6B,IAA7B,KAAsC,QAAA,CAAA,UAAA,CAAW,MAArF,EAA6F;AAC3F,WAAO,IAAP;AACD,GAHuE,CAKxE;AACA;;;AACA,MAAI,gBAAgB,CAAC,WAAjB,IAAgC,gBAAgB,CAAC,WAAjB,YAAwC,sBAAA,CAAA,mBAA5E,EAAiG;AAC/F,UAAM,OAAO,GAAwB,KAAK,CAAC,IAAN,CAAW,gBAAgB,CAAC,WAAjB,CAA6B,OAA7B,CAAqC,MAArC,EAAX,CAArC;AACA,WAAO,OAAO,CAAC,IAAR,CAAc,MAAD,IAA+B,MAAM,CAAC,IAAP,KAAgB,QAAA,CAAA,UAAA,CAAW,MAAvE,CAAP;AACD;;AAED,SAAO,KAAP;AACD;;AAbD,OAAA,CAAA,SAAA,GAAA,SAAA","sourcesContent":["import type { Document } from '../../bson';\nimport { MongoInvalidArgumentError } from '../../error';\nimport type { ReadPreferenceLike } from '../../read_preference';\nimport { ReadPreference } from '../../read_preference';\nimport { ServerType } from '../../sdam/common';\nimport type { Server } from '../../sdam/server';\nimport type { ServerDescription } from '../../sdam/server_description';\nimport type { Topology } from '../../sdam/topology';\nimport { TopologyDescription } from '../../sdam/topology_description';\nimport type { OpQueryOptions } from '../commands';\nimport type { CommandOptions, Connection } from '../connection';\n\nexport interface ReadPreferenceOption {\n  readPreference?: ReadPreferenceLike;\n}\n\nexport function getReadPreference(cmd: Document, options?: ReadPreferenceOption): ReadPreference {\n  // Default to command version of the readPreference\n  let readPreference = cmd.readPreference || ReadPreference.primary;\n  // If we have an option readPreference override the command one\n  if (options?.readPreference) {\n    readPreference = options.readPreference;\n  }\n\n  if (typeof readPreference === 'string') {\n    readPreference = ReadPreference.fromString(readPreference);\n  }\n\n  if (!(readPreference instanceof ReadPreference)) {\n    throw new MongoInvalidArgumentError(\n      'Option \"readPreference\" must be a ReadPreference instance'\n    );\n  }\n\n  return readPreference;\n}\n\nexport function applyCommonQueryOptions(\n  queryOptions: OpQueryOptions,\n  options: CommandOptions\n): CommandOptions {\n  Object.assign(queryOptions, {\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation:\n      typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true\n  });\n\n  if (options.session) {\n    queryOptions.session = options.session;\n  }\n\n  return queryOptions;\n}\n\nexport function isSharded(topologyOrServer: Topology | Server | Connection): boolean {\n  if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {\n    return true;\n  }\n\n  // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n  if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {\n    const servers: ServerDescription[] = Array.from(topologyOrServer.description.servers.values());\n    return servers.some((server: ServerDescription) => server.type === ServerType.Mongos);\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}