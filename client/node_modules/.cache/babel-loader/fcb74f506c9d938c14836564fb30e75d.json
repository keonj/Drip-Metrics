{"ast":null,"code":"import _isEqual from 'lodash/isEqual';\nimport _isEmpty from 'lodash/isEmpty';\nimport { EJSON } from 'bson';\nimport { Chatty } from '@looker/chatty'; // Given an object `Target`, find all property names of type `Type`\n// Given an object `Target`, filter out all properties that aren't of type `Type`\n\nfunction createElement(name) {\n  let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const element = document.createElement(name);\n\n  for (const [name, value] of Object.entries(props)) {\n    if (name === 'style') {\n      Object.assign(element.style, props.style);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n\n  for (const child of Array.isArray(children) ? children : [children]) {\n    element.append(child);\n  }\n\n  return element;\n}\n/**\n * Constructs the chart iframe URL from the baseUrl, chartId & tenantId\n */\n\n\nconst getChartUrl = options => {\n  try {\n    const url = new URL(options.baseUrl);\n    url.pathname = [url.pathname, url.pathname.slice(-1) === '/' ? '' : '/', 'embed/charts'].join('');\n    url.search = `id=${options.chartId}&sdk=2`;\n\n    if (options.autoRefresh) {\n      url.search += `&autorefresh=${options.autoRefresh}`;\n    } else {\n      url.search += options.refreshInterval ? `&autorefresh=${options.refreshInterval}` : '';\n    }\n\n    if (options.maxDataAge !== undefined) {\n      url.search += `&maxDataAge=${options.maxDataAge}`;\n    }\n\n    url.search += options.filter ? `&filter=${encodeURIComponent(EJSON.stringify(options.filter, {\n      relaxed: false\n    }))}` : '';\n    url.search += options.theme ? `&theme=${options.theme}` : '';\n    url.search += options.showAttribution === false ? `&attribution=${options.showAttribution}` : '';\n    return url.toString();\n  } catch (e) {\n    throw new Error('Base URL must be a valid URL');\n  }\n};\n/* Parses a CSS Measurement from an unknown value\n     - if it's a string, we trust that it is well-formed\n     - if it's a number, we assume the units are pixels\n     - otherwise we return null\n*/\n\n\nconst parseCSSMeasurement = value => {\n  if (typeof value === 'string') return value;\n  if (typeof value === 'number') return `${value}px`;\n  return null;\n};\n/**\n * Returns the background after validation checks\n * or default background based on theme if not set\n */\n\n\nconst getBackground = (background, theme) => {\n  if (typeof background === 'string' && background.length > 0) return background;\n  if (theme === 'dark') return '#21313C';\n  return '#FFFFFF';\n}; // Disabled temporarily to fix: https://github.com/mongodb-js/charts-embed-sdk/issues/14\n// Until we come up with a better way to have strong typing for the Stitch client, while\n// also not breaking normal TSC compiles of the SDK\n// import type { StitchAppClient } from 'mongodb-stitch-browser-sdk';\n\n\nconst isJWTExpired = jwt => {\n  try {\n    const [header, payload, signature] = jwt.split('.');\n    const {\n      exp\n    } = JSON.parse(atob(payload)); // Check the current time against the expiry (minus 5 minutes) in the token\n\n    return Date.now() / 1000 >= exp - 300;\n  } catch (e) {\n    throw new Error('Failed to parse Realm token. Is the StitchClient configured correctly?');\n  }\n};\n/**\n * A helper utility to support using [Realm Authentication](https://docs.mongodb.com/stitch/) with MongoDB Charts\n *\n * ```js\n * const client = Stitch.initializeDefaultAppClient('<your-client-app-id>');\n * client.auth.loginWithCredential(...)\n *\n * const sdk = new ChartsEmbedSDK({\n *   getUserToken: () => getRealmUserToken(client)\n * })\n * ```\n */\n\n\nasync function getRealmUserToken(stitchAppClient) {\n  const client = stitchAppClient;\n\n  if (!client.auth || !client.auth.authInfo) {\n    throw new Error('Unfamiliar Stitch client version');\n  }\n\n  if (!client.auth.isLoggedIn) {\n    throw new Error('Could not find a logged-in StitchUser. Is the StitchClient configured correctly?');\n  }\n\n  if (!client.auth.authInfo.accessToken) {\n    throw new Error('Could not find a valid JWT. Is the StitchClient configured correctly?');\n  }\n\n  if (isJWTExpired(client.auth.authInfo.accessToken)) {\n    // Attempt to refresh token using progression from public -> private apis\n    if (client.auth.refreshCustomData) {\n      await client.auth.refreshCustomData(); // supported from 4.8.0\n    } else if (client.auth.refreshAccessToken) {\n      await client.auth.refreshAccessToken(); // supported from 4.0.0\n    } else {\n      throw new Error('Could not refresh token. Unfamiliar Stitch client version');\n    }\n  }\n\n  return client.auth.authInfo.accessToken;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst getChartOptions = options => {\n  if (typeof options !== 'object' || options === null) {\n    throw new Error('Options argument must be an object');\n  }\n\n  const {\n    background,\n    baseUrl,\n    chartId,\n    filter,\n    refreshInterval,\n    autoRefresh,\n    maxDataAge,\n    width,\n    height,\n    theme,\n    showAttribution,\n    getUserToken\n  } = options;\n\n  if (typeof baseUrl !== 'string' || baseUrl.length === 0) {\n    throw new Error('Base URL must be a valid URL');\n  }\n\n  if (typeof chartId !== 'string' || chartId.length === 0) {\n    throw new Error('Chart ID must be specified');\n  }\n\n  if (width !== undefined && !['number', 'string'].includes(typeof width)) {\n    throw new Error('Width must be a string or number if specified');\n  }\n\n  if (height !== undefined && !['number', 'string'].includes(typeof height)) {\n    throw new Error('Height must be a string or number if specified');\n  }\n\n  if (filter !== undefined && (!filter || typeof filter !== 'object')) {\n    throw new Error('Filter must be an object if specified');\n  }\n\n  if (refreshInterval !== undefined && typeof refreshInterval !== 'number') {\n    throw new Error('refreshInterval interval must be a number if specified');\n  }\n\n  if (autoRefresh !== undefined && typeof autoRefresh !== 'boolean') {\n    throw new Error('autoRefresh must be a boolean if specified');\n  }\n\n  if (maxDataAge !== undefined && typeof maxDataAge !== 'number') {\n    throw new Error('maxDataAge must be a number if specified');\n  }\n\n  if (theme !== undefined && typeof theme !== 'string') {\n    throw new Error('Theme must be a string if specified');\n  }\n\n  if (showAttribution !== undefined && typeof showAttribution !== 'boolean') {\n    throw new Error('Attribution must be a boolean value if specified');\n  }\n\n  if (getUserToken !== undefined && typeof getUserToken !== 'function') {\n    throw new Error('getUserToken must be a function');\n  }\n\n  if (background !== undefined && typeof background !== 'string') {\n    throw new Error('background must be a string if specified');\n  }\n\n  return {\n    background,\n    baseUrl,\n    chartId,\n    filter,\n    refreshInterval,\n    autoRefresh,\n    maxDataAge,\n    width,\n    height,\n    theme,\n    showAttribution,\n    getUserToken\n  };\n};\n\nlet eventHandlerIndex = Date.now();\n/**\n * # Chart\n *\n * Allows you to interact and embed charts into your application.\n *\n * ```js\n * const sdk = new EmbedSDK({ ... });\n * const chart = sdk.createChart({ ... });\n *\n * // renders a chart\n * chart.render(document.getElementById('embed-chart'));\n *\n * // dynamically set a filter\n * chart.setFilter({ age: { $gt: 50 } });\n * ```\n */\n\nclass Chart {\n  /** @ignore */\n\n  /** @ignore */\n  constructor(options) {\n    _defineProperty(this, \"iframe\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"eventHandlers\", {\n      click: {} // refresh: {} To be added soon\n\n    });\n\n    this.options = getChartOptions(options);\n  }\n\n  _send(eventName) {\n    if (this.connection) {\n      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        payload[_key - 1] = arguments[_key];\n      }\n\n      return this.connection.sendAndReceive(eventName, ...payload);\n    }\n\n    return Promise.reject('Chart has not been rendered. Ensure that you wait for the promise returned by `chart.render()` before trying to manipulate a chart.');\n  }\n\n  async setToken(token) {\n    await this._send('set', 'token', token);\n  }\n\n  async retrieveAndSetToken() {\n    if (this.options.getUserToken) {\n      const token = await this.options.getUserToken();\n      this.setToken(token);\n    }\n  }\n  /**\n   * Triggers a refresh of the chart (if it has been embedded).\n   *\n   * @returns a promise that resolves once the chart updated its data\n   */\n\n\n  async refresh() {\n    await this._send('refresh');\n  }\n  /**\n   * @returns the number of seconds a chart will wait before refreshing\n   */\n\n\n  async getRefreshInterval() {\n    const [result] = await this._send('get', 'autorefresh');\n    return typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set the number of seconds a chart will wait before refreshing.\n   *\n   * The minimum refresh interval is 10 seconds. To disable, set the refresh interval to 0.\n   */\n\n\n  async setRefreshInterval(value) {\n    if (typeof value !== 'number') {\n      return Promise.reject('refreshInterval property value should be a number');\n    }\n\n    await this._send('set', 'autorefresh', value);\n  }\n  /**\n   * @returns the number of seconds before a chart's data expires\n   */\n\n\n  async getMaxDataAge() {\n    const [result] = await this._send('get', 'maxDataAge');\n    return typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set the number of seconds a chart's data expires.\n   */\n\n\n  async setMaxDataAge(value) {\n    if (typeof value !== 'number') {\n      return Promise.reject('maxDataAge property value should be a number');\n    }\n\n    await this._send('set', 'maxDataAge', value);\n  }\n  /**\n   * @returns whether auto refreshing is enabled\n   */\n\n\n  async isAutoRefresh() {\n    const [result] = await this._send('get', 'autorefresh');\n    return typeof result === 'number' || typeof result === 'boolean' ? Boolean(result) : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Enable/Disable auto refreshing.\n   */\n\n\n  async setAutoRefresh(value) {\n    if (typeof value !== 'boolean') {\n      return Promise.reject('autoRefresh property value should be a boolean');\n    }\n\n    await this._send('set', 'autorefresh', value);\n  }\n  /**\n   * @returns the current filter applied to the embedded chart.\n   */\n\n\n  async getFilter() {\n    const [result] = await this._send('get', 'filter');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Sets the filter to apply to the embedded chart.\n   *\n   * This expects an object that contains a valid [query operators](https://docs.mongodb.com/manual/reference/operator/query/#query-selectors).\n   * Any fields referenced in this filter are expected to be whitelisted in the \"Embed Chart\" dialog for each Chart you wish to filter on.\n   */\n\n\n  async setFilter(value) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      return Promise.reject('filter property value should be an object');\n    }\n\n    await this._send('set', 'filter', EJSON.stringify(value, {\n      relaxed: false\n    }));\n  }\n  /**\n   * @returns the current highlight applied to the embedded chart.\n   */\n\n\n  async getHighlight() {\n    const [result] = await this._send('get', 'highlight');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Sets the highlight to apply to the embedded chart.\n   *\n   * This is the exact same object that can be used in 'setFilter'.\n   * However, it [doesn't support some query expressions](https://docs.mongodb.com/charts/saas/embedded-chart-options/)\n   * @param value The highlight object to be applied to the chart\n   */\n\n\n  async setHighlight(value) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      return Promise.reject('highlight property value should be an object');\n    }\n\n    await this._send('set', 'highlight', EJSON.stringify(value, {\n      relaxed: false\n    }));\n  }\n  /**\n   * Sets the color scheme to apply to the chart.\n   *\n   * If the theme is set to 'dark' and you have specified a custom background color, you should ensure that your background color has appropriate contrast.\n   */\n\n\n  async setTheme(value) {\n    if (typeof value !== 'string') {\n      return Promise.reject('theme property value should be a string');\n    }\n\n    await this._send('set', 'theme', value);\n\n    if (this.iframe) {\n      this.iframe.style.backgroundColor = getBackground(this.options.background, value);\n    }\n  }\n  /**\n   * @returns the current theme applied to the chart\n   */\n\n\n  async getTheme() {\n    const [result] = await this._send('get', 'theme');\n    return typeof result === 'string' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Sets an event listener\n   * @param event - the event you are subscribing to\n   * @param eventHandler - the callback to be executed when the event is triggered\n   * @param options - optional options object, can be used to customise when handler is called\n   */\n\n\n  addEventListener(event, eventHandler, options) {\n    var _h$options$includes;\n\n    const handlers = this.eventHandlers[event];\n\n    if (!handlers) {\n      throw new Error(`Not supported event: ${event}`);\n    }\n\n    const h = {\n      handle: eventHandler,\n      options: {\n        includes: options === null || options === void 0 ? void 0 : options.includes\n      }\n    };\n\n    if ((_h$options$includes = h.options.includes) !== null && _h$options$includes !== void 0 && _h$options$includes.every(f => _isEmpty(f))) {\n      // eslint-disable-next-line no-console\n      console.warn('Empty includes filters out all events. Event handler will never be called. Is this intended?');\n    } // ignore if same handler and options have been added already\n\n\n    if (!Object.keys(handlers).some(id => _isEqual(handlers[id], h))) {\n      const handlerId = (++eventHandlerIndex).toString(36);\n      handlers[handlerId] = h;\n      return this._send('eventHandler', event, handlerId, h.options);\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Removes an event listener\n   * @param event - the event you are unsubscribing from\n   * @param eventHandler - the event listener function you are unsubscribing from\n   * @param options - optional options object used when addEventListener\n   */\n\n\n  removeEventListener(event, eventHandler, options) {\n    const handlers = this.eventHandlers[event];\n\n    if (!handlers) {\n      throw new Error(`Not supported event: ${event}`);\n    }\n\n    const h = {\n      handle: eventHandler,\n      options: {\n        includes: options === null || options === void 0 ? void 0 : options.includes\n      }\n    };\n    const handlerId = Object.keys(handlers).find(id => _isEqual(handlers[id], h));\n\n    if (handlerId) {\n      delete handlers[handlerId];\n      return this._send('eventHandler', event, handlerId);\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Renders a chart into the given `container`.\n   *\n   * This method should only be called once, and successive attempts to call `render`\n   * will fail with an error.\n   *\n   * @returns a promise that will resolve once the chart has successfully been embedded\n   */\n\n\n  async render(container) {\n    if (this.iframe) {\n      throw new Error('A chart can only be rendered into a container once');\n    }\n\n    if (!(container instanceof HTMLElement)) {\n      throw new Error('Target container must be a HTML element');\n    } // Remove any existing nodes in our target container\n\n\n    while (container.firstChild) container.removeChild(container.firstChild);\n\n    const chartUrl = getChartUrl(this.options); // Create styled container\n\n    const embedRoot = createElement('div', {\n      style: {\n        position: 'relative',\n        overflow: 'hidden',\n        width: parseCSSMeasurement(this.options.width) || '100%',\n        height: parseCSSMeasurement(this.options.height) || '100%',\n        minHeight: Boolean(this.options.height) ? 0 : '15px',\n        backgroundColor: getBackground(this.options.background, this.options.theme)\n      }\n    }); // Create iframe\n\n    const host = Chatty.createHost(chartUrl).withSandboxAttribute('allow-scripts').withSandboxAttribute('allow-same-origin').withSandboxAttribute('allow-popups').withSandboxAttribute('allow-popups-to-escape-sandbox').appendTo(embedRoot).on('refreshToken', () => this.retrieveAndSetToken()).on('event', (event, payload, handlerIds) => {\n      const handlers = this.eventHandlers[event];\n\n      for (const id of handlerIds) {\n        try {\n          var _handlers$id; // since communication between host and SDK is asyc,\n          // it's possible that some handlers have been removed;\n          // thus needs to check if handler still exists before calling\n\n\n          (_handlers$id = handlers[id]) === null || _handlers$id === void 0 ? void 0 : _handlers$id.handle(payload);\n        } catch (error) {\n          console.warn(`Error calling handler for event [${event}]: ${error}`);\n        }\n      }\n    }).build(); // Customise IFrame styles\n\n    Object.assign(host.iframe.style, {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      border: 0\n    });\n    host.iframe.setAttribute('aria-label', 'Embedded Chart');\n    container.appendChild(embedRoot);\n    this.iframe = host.iframe;\n    const connection = await host.connect();\n    this.connection = connection;\n    await this.retrieveAndSetToken(); // ready to render chart\n\n    await this._send('ready');\n  }\n\n}\n/**\n * Creates an instance of the embedding SDK\n */\n\n\nclass EmbedSDK {\n  /**\n   * Accepts an optional {@link EmbedChartOptions} object to use as the\n   * default options for any charts created using this SDK instance.\n   *\n   * ```js\n   * const sdk = new EmbedSDK({\n   *   baseUrl: \"https://charts.mongodb.com\",\n   * })\n   * ```\n   */\n  constructor(options) {\n    _defineProperty(this, \"defaultOptions\", void 0);\n\n    this.defaultOptions = options;\n  }\n  /**\n   * Creates a new {@link Chart} instance that allows you to\n   * interact with and embed charts into your application\n   */\n\n\n  createChart(options) {\n    return new Chart({ ...this.defaultOptions,\n      ...options\n    });\n  }\n\n}\n\nexport default EmbedSDK;\nexport { getRealmUserToken };","map":{"version":3,"sources":["C:/Western/Ivey/WEC/Drip-Metrics/Drip-Metrics/node_modules/@mongodb-js/charts-embed-dom/dist/charts-embed-dom.esm.js"],"names":["_isEqual","_isEmpty","EJSON","Chatty","createElement","name","props","children","element","document","value","Object","entries","assign","style","setAttribute","child","Array","isArray","append","getChartUrl","options","url","URL","baseUrl","pathname","slice","join","search","chartId","autoRefresh","refreshInterval","maxDataAge","undefined","filter","encodeURIComponent","stringify","relaxed","theme","showAttribution","toString","e","Error","parseCSSMeasurement","getBackground","background","length","isJWTExpired","jwt","header","payload","signature","split","exp","JSON","parse","atob","Date","now","getRealmUserToken","stitchAppClient","client","auth","authInfo","isLoggedIn","accessToken","refreshCustomData","refreshAccessToken","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","getChartOptions","width","height","getUserToken","includes","eventHandlerIndex","Chart","constructor","click","_send","eventName","connection","sendAndReceive","Promise","reject","setToken","token","retrieveAndSetToken","refresh","getRefreshInterval","result","setRefreshInterval","getMaxDataAge","setMaxDataAge","isAutoRefresh","Boolean","setAutoRefresh","getFilter","setFilter","getHighlight","setHighlight","setTheme","iframe","backgroundColor","getTheme","addEventListener","event","eventHandler","_h$options$includes","handlers","eventHandlers","h","handle","every","f","console","warn","keys","some","id","handlerId","resolve","removeEventListener","find","render","container","HTMLElement","firstChild","removeChild","chartUrl","embedRoot","position","overflow","minHeight","host","createHost","withSandboxAttribute","appendTo","on","handlerIds","_handlers$id","error","build","top","left","border","appendChild","connect","EmbedSDK","defaultOptions","createChart"],"mappings":"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","sourcesContent":["import _isEqual from 'lodash/isEqual';\nimport _isEmpty from 'lodash/isEmpty';\nimport { EJSON } from 'bson';\nimport { Chatty } from '@looker/chatty';\n\n// Given an object `Target`, find all property names of type `Type`\n// Given an object `Target`, filter out all properties that aren't of type `Type`\nfunction createElement(name, props = {}, children = []) {\n  const element = document.createElement(name);\n\n  for (const [name, value] of Object.entries(props)) {\n    if (name === 'style') {\n      Object.assign(element.style, props.style);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n\n  for (const child of Array.isArray(children) ? children : [children]) {\n    element.append(child);\n  }\n\n  return element;\n}\n\n/**\n * Constructs the chart iframe URL from the baseUrl, chartId & tenantId\n */\nconst getChartUrl = options => {\n  try {\n    const url = new URL(options.baseUrl);\n    url.pathname = [url.pathname, url.pathname.slice(-1) === '/' ? '' : '/', 'embed/charts'].join('');\n    url.search = `id=${options.chartId}&sdk=2`;\n\n    if (options.autoRefresh) {\n      url.search += `&autorefresh=${options.autoRefresh}`;\n    } else {\n      url.search += options.refreshInterval ? `&autorefresh=${options.refreshInterval}` : '';\n    }\n\n    if (options.maxDataAge !== undefined) {\n      url.search += `&maxDataAge=${options.maxDataAge}`;\n    }\n\n    url.search += options.filter ? `&filter=${encodeURIComponent(EJSON.stringify(options.filter, {\n      relaxed: false\n    }))}` : '';\n    url.search += options.theme ? `&theme=${options.theme}` : '';\n    url.search += options.showAttribution === false ? `&attribution=${options.showAttribution}` : '';\n    return url.toString();\n  } catch (e) {\n    throw new Error('Base URL must be a valid URL');\n  }\n};\n/* Parses a CSS Measurement from an unknown value\n     - if it's a string, we trust that it is well-formed\n     - if it's a number, we assume the units are pixels\n     - otherwise we return null\n*/\n\nconst parseCSSMeasurement = value => {\n  if (typeof value === 'string') return value;\n  if (typeof value === 'number') return `${value}px`;\n  return null;\n};\n/**\n * Returns the background after validation checks\n * or default background based on theme if not set\n */\n\nconst getBackground = (background, theme) => {\n  if (typeof background === 'string' && background.length > 0) return background;\n  if (theme === 'dark') return '#21313C';\n  return '#FFFFFF';\n};\n\n// Disabled temporarily to fix: https://github.com/mongodb-js/charts-embed-sdk/issues/14\n// Until we come up with a better way to have strong typing for the Stitch client, while\n// also not breaking normal TSC compiles of the SDK\n// import type { StitchAppClient } from 'mongodb-stitch-browser-sdk';\nconst isJWTExpired = jwt => {\n  try {\n    const [header, payload, signature] = jwt.split('.');\n    const {\n      exp\n    } = JSON.parse(atob(payload)); // Check the current time against the expiry (minus 5 minutes) in the token\n\n    return Date.now() / 1000 >= exp - 300;\n  } catch (e) {\n    throw new Error('Failed to parse Realm token. Is the StitchClient configured correctly?');\n  }\n};\n/**\n * A helper utility to support using [Realm Authentication](https://docs.mongodb.com/stitch/) with MongoDB Charts\n *\n * ```js\n * const client = Stitch.initializeDefaultAppClient('<your-client-app-id>');\n * client.auth.loginWithCredential(...)\n *\n * const sdk = new ChartsEmbedSDK({\n *   getUserToken: () => getRealmUserToken(client)\n * })\n * ```\n */\n\n\nasync function getRealmUserToken(stitchAppClient) {\n  const client = stitchAppClient;\n\n  if (!client.auth || !client.auth.authInfo) {\n    throw new Error('Unfamiliar Stitch client version');\n  }\n\n  if (!client.auth.isLoggedIn) {\n    throw new Error('Could not find a logged-in StitchUser. Is the StitchClient configured correctly?');\n  }\n\n  if (!client.auth.authInfo.accessToken) {\n    throw new Error('Could not find a valid JWT. Is the StitchClient configured correctly?');\n  }\n\n  if (isJWTExpired(client.auth.authInfo.accessToken)) {\n    // Attempt to refresh token using progression from public -> private apis\n    if (client.auth.refreshCustomData) {\n      await client.auth.refreshCustomData(); // supported from 4.8.0\n    } else if (client.auth.refreshAccessToken) {\n      await client.auth.refreshAccessToken(); // supported from 4.0.0\n    } else {\n      throw new Error('Could not refresh token. Unfamiliar Stitch client version');\n    }\n  }\n\n  return client.auth.authInfo.accessToken;\n}\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst getChartOptions = options => {\n  if (typeof options !== 'object' || options === null) {\n    throw new Error('Options argument must be an object');\n  }\n\n  const {\n    background,\n    baseUrl,\n    chartId,\n    filter,\n    refreshInterval,\n    autoRefresh,\n    maxDataAge,\n    width,\n    height,\n    theme,\n    showAttribution,\n    getUserToken\n  } = options;\n\n  if (typeof baseUrl !== 'string' || baseUrl.length === 0) {\n    throw new Error('Base URL must be a valid URL');\n  }\n\n  if (typeof chartId !== 'string' || chartId.length === 0) {\n    throw new Error('Chart ID must be specified');\n  }\n\n  if (width !== undefined && !['number', 'string'].includes(typeof width)) {\n    throw new Error('Width must be a string or number if specified');\n  }\n\n  if (height !== undefined && !['number', 'string'].includes(typeof height)) {\n    throw new Error('Height must be a string or number if specified');\n  }\n\n  if (filter !== undefined && (!filter || typeof filter !== 'object')) {\n    throw new Error('Filter must be an object if specified');\n  }\n\n  if (refreshInterval !== undefined && typeof refreshInterval !== 'number') {\n    throw new Error('refreshInterval interval must be a number if specified');\n  }\n\n  if (autoRefresh !== undefined && typeof autoRefresh !== 'boolean') {\n    throw new Error('autoRefresh must be a boolean if specified');\n  }\n\n  if (maxDataAge !== undefined && typeof maxDataAge !== 'number') {\n    throw new Error('maxDataAge must be a number if specified');\n  }\n\n  if (theme !== undefined && typeof theme !== 'string') {\n    throw new Error('Theme must be a string if specified');\n  }\n\n  if (showAttribution !== undefined && typeof showAttribution !== 'boolean') {\n    throw new Error('Attribution must be a boolean value if specified');\n  }\n\n  if (getUserToken !== undefined && typeof getUserToken !== 'function') {\n    throw new Error('getUserToken must be a function');\n  }\n\n  if (background !== undefined && typeof background !== 'string') {\n    throw new Error('background must be a string if specified');\n  }\n\n  return {\n    background,\n    baseUrl,\n    chartId,\n    filter,\n    refreshInterval,\n    autoRefresh,\n    maxDataAge,\n    width,\n    height,\n    theme,\n    showAttribution,\n    getUserToken\n  };\n};\n\nlet eventHandlerIndex = Date.now();\n/**\n * # Chart\n *\n * Allows you to interact and embed charts into your application.\n *\n * ```js\n * const sdk = new EmbedSDK({ ... });\n * const chart = sdk.createChart({ ... });\n *\n * // renders a chart\n * chart.render(document.getElementById('embed-chart'));\n *\n * // dynamically set a filter\n * chart.setFilter({ age: { $gt: 50 } });\n * ```\n */\n\nclass Chart {\n  /** @ignore */\n\n  /** @ignore */\n  constructor(options) {\n    _defineProperty(this, \"iframe\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"eventHandlers\", {\n      click: {} // refresh: {} To be added soon\n\n    });\n\n    this.options = getChartOptions(options);\n  }\n\n  _send(eventName, ...payload) {\n    if (this.connection) {\n      return this.connection.sendAndReceive(eventName, ...payload);\n    }\n\n    return Promise.reject('Chart has not been rendered. Ensure that you wait for the promise returned by `chart.render()` before trying to manipulate a chart.');\n  }\n\n  async setToken(token) {\n    await this._send('set', 'token', token);\n  }\n\n  async retrieveAndSetToken() {\n    if (this.options.getUserToken) {\n      const token = await this.options.getUserToken();\n      this.setToken(token);\n    }\n  }\n  /**\n   * Triggers a refresh of the chart (if it has been embedded).\n   *\n   * @returns a promise that resolves once the chart updated its data\n   */\n\n\n  async refresh() {\n    await this._send('refresh');\n  }\n  /**\n   * @returns the number of seconds a chart will wait before refreshing\n   */\n\n\n  async getRefreshInterval() {\n    const [result] = await this._send('get', 'autorefresh');\n    return typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set the number of seconds a chart will wait before refreshing.\n   *\n   * The minimum refresh interval is 10 seconds. To disable, set the refresh interval to 0.\n   */\n\n\n  async setRefreshInterval(value) {\n    if (typeof value !== 'number') {\n      return Promise.reject('refreshInterval property value should be a number');\n    }\n\n    await this._send('set', 'autorefresh', value);\n  }\n  /**\n   * @returns the number of seconds before a chart's data expires\n   */\n\n\n  async getMaxDataAge() {\n    const [result] = await this._send('get', 'maxDataAge');\n    return typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set the number of seconds a chart's data expires.\n   */\n\n\n  async setMaxDataAge(value) {\n    if (typeof value !== 'number') {\n      return Promise.reject('maxDataAge property value should be a number');\n    }\n\n    await this._send('set', 'maxDataAge', value);\n  }\n  /**\n   * @returns whether auto refreshing is enabled\n   */\n\n\n  async isAutoRefresh() {\n    const [result] = await this._send('get', 'autorefresh');\n    return typeof result === 'number' || typeof result === 'boolean' ? Boolean(result) : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Enable/Disable auto refreshing.\n   */\n\n\n  async setAutoRefresh(value) {\n    if (typeof value !== 'boolean') {\n      return Promise.reject('autoRefresh property value should be a boolean');\n    }\n\n    await this._send('set', 'autorefresh', value);\n  }\n  /**\n   * @returns the current filter applied to the embedded chart.\n   */\n\n\n  async getFilter() {\n    const [result] = await this._send('get', 'filter');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Sets the filter to apply to the embedded chart.\n   *\n   * This expects an object that contains a valid [query operators](https://docs.mongodb.com/manual/reference/operator/query/#query-selectors).\n   * Any fields referenced in this filter are expected to be whitelisted in the \"Embed Chart\" dialog for each Chart you wish to filter on.\n   */\n\n\n  async setFilter(value) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      return Promise.reject('filter property value should be an object');\n    }\n\n    await this._send('set', 'filter', EJSON.stringify(value, {\n      relaxed: false\n    }));\n  }\n  /**\n   * @returns the current highlight applied to the embedded chart.\n   */\n\n\n  async getHighlight() {\n    const [result] = await this._send('get', 'highlight');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Sets the highlight to apply to the embedded chart.\n   *\n   * This is the exact same object that can be used in 'setFilter'.\n   * However, it [doesn't support some query expressions](https://docs.mongodb.com/charts/saas/embedded-chart-options/)\n   * @param value The highlight object to be applied to the chart\n   */\n\n\n  async setHighlight(value) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      return Promise.reject('highlight property value should be an object');\n    }\n\n    await this._send('set', 'highlight', EJSON.stringify(value, {\n      relaxed: false\n    }));\n  }\n  /**\n   * Sets the color scheme to apply to the chart.\n   *\n   * If the theme is set to 'dark' and you have specified a custom background color, you should ensure that your background color has appropriate contrast.\n   */\n\n\n  async setTheme(value) {\n    if (typeof value !== 'string') {\n      return Promise.reject('theme property value should be a string');\n    }\n\n    await this._send('set', 'theme', value);\n\n    if (this.iframe) {\n      this.iframe.style.backgroundColor = getBackground(this.options.background, value);\n    }\n  }\n  /**\n   * @returns the current theme applied to the chart\n   */\n\n\n  async getTheme() {\n    const [result] = await this._send('get', 'theme');\n    return typeof result === 'string' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Sets an event listener\n   * @param event - the event you are subscribing to\n   * @param eventHandler - the callback to be executed when the event is triggered\n   * @param options - optional options object, can be used to customise when handler is called\n   */\n\n\n  addEventListener(event, eventHandler, options) {\n    var _h$options$includes;\n\n    const handlers = this.eventHandlers[event];\n\n    if (!handlers) {\n      throw new Error(`Not supported event: ${event}`);\n    }\n\n    const h = {\n      handle: eventHandler,\n      options: {\n        includes: options === null || options === void 0 ? void 0 : options.includes\n      }\n    };\n\n    if ((_h$options$includes = h.options.includes) !== null && _h$options$includes !== void 0 && _h$options$includes.every(f => _isEmpty(f))) {\n      // eslint-disable-next-line no-console\n      console.warn('Empty includes filters out all events. Event handler will never be called. Is this intended?');\n    } // ignore if same handler and options have been added already\n\n\n    if (!Object.keys(handlers).some(id => _isEqual(handlers[id], h))) {\n      const handlerId = (++eventHandlerIndex).toString(36);\n      handlers[handlerId] = h;\n      return this._send('eventHandler', event, handlerId, h.options);\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Removes an event listener\n   * @param event - the event you are unsubscribing from\n   * @param eventHandler - the event listener function you are unsubscribing from\n   * @param options - optional options object used when addEventListener\n   */\n\n\n  removeEventListener(event, eventHandler, options) {\n    const handlers = this.eventHandlers[event];\n\n    if (!handlers) {\n      throw new Error(`Not supported event: ${event}`);\n    }\n\n    const h = {\n      handle: eventHandler,\n      options: {\n        includes: options === null || options === void 0 ? void 0 : options.includes\n      }\n    };\n    const handlerId = Object.keys(handlers).find(id => _isEqual(handlers[id], h));\n\n    if (handlerId) {\n      delete handlers[handlerId];\n      return this._send('eventHandler', event, handlerId);\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Renders a chart into the given `container`.\n   *\n   * This method should only be called once, and successive attempts to call `render`\n   * will fail with an error.\n   *\n   * @returns a promise that will resolve once the chart has successfully been embedded\n   */\n\n\n  async render(container) {\n    if (this.iframe) {\n      throw new Error('A chart can only be rendered into a container once');\n    }\n\n    if (!(container instanceof HTMLElement)) {\n      throw new Error('Target container must be a HTML element');\n    } // Remove any existing nodes in our target container\n\n\n    while (container.firstChild) container.removeChild(container.firstChild);\n\n    const chartUrl = getChartUrl(this.options); // Create styled container\n\n    const embedRoot = createElement('div', {\n      style: {\n        position: 'relative',\n        overflow: 'hidden',\n        width: parseCSSMeasurement(this.options.width) || '100%',\n        height: parseCSSMeasurement(this.options.height) || '100%',\n        minHeight: Boolean(this.options.height) ? 0 : '15px',\n        backgroundColor: getBackground(this.options.background, this.options.theme)\n      }\n    }); // Create iframe\n\n    const host = Chatty.createHost(chartUrl).withSandboxAttribute('allow-scripts').withSandboxAttribute('allow-same-origin').withSandboxAttribute('allow-popups').withSandboxAttribute('allow-popups-to-escape-sandbox').appendTo(embedRoot).on('refreshToken', () => this.retrieveAndSetToken()).on('event', (event, payload, handlerIds) => {\n      const handlers = this.eventHandlers[event];\n\n      for (const id of handlerIds) {\n        try {\n          var _handlers$id;\n\n          // since communication between host and SDK is asyc,\n          // it's possible that some handlers have been removed;\n          // thus needs to check if handler still exists before calling\n          (_handlers$id = handlers[id]) === null || _handlers$id === void 0 ? void 0 : _handlers$id.handle(payload);\n        } catch (error) {\n          console.warn(`Error calling handler for event [${event}]: ${error}`);\n        }\n      }\n    }).build(); // Customise IFrame styles\n\n    Object.assign(host.iframe.style, {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      border: 0\n    });\n    host.iframe.setAttribute('aria-label', 'Embedded Chart');\n    container.appendChild(embedRoot);\n    this.iframe = host.iframe;\n    const connection = await host.connect();\n    this.connection = connection;\n    await this.retrieveAndSetToken(); // ready to render chart\n\n    await this._send('ready');\n  }\n\n}\n/**\n * Creates an instance of the embedding SDK\n */\n\n\nclass EmbedSDK {\n  /**\n   * Accepts an optional {@link EmbedChartOptions} object to use as the\n   * default options for any charts created using this SDK instance.\n   *\n   * ```js\n   * const sdk = new EmbedSDK({\n   *   baseUrl: \"https://charts.mongodb.com\",\n   * })\n   * ```\n   */\n  constructor(options) {\n    _defineProperty(this, \"defaultOptions\", void 0);\n\n    this.defaultOptions = options;\n  }\n  /**\n   * Creates a new {@link Chart} instance that allows you to\n   * interact with and embed charts into your application\n   */\n\n\n  createChart(options) {\n    return new Chart({ ...this.defaultOptions,\n      ...options\n    });\n  }\n\n}\n\nexport default EmbedSDK;\nexport { getRealmUserToken };\n"]},"metadata":{},"sourceType":"module"}